//! AI Junk Cleanup module for Dev Janitor v2
//! Detects and cleans up files generated by AI coding assistants

use rayon::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

/// Represents an AI junk file detected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AiJunkFile {
    pub id: String,
    pub name: String,
    pub path: String,
    pub size: u64,
    pub size_display: String,
    pub junk_type: String,
    pub reason: String,
}

/// Scan mode for AI junk detection
#[allow(dead_code)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ScanMode {
    FullDisk,
    Directory(String),
}

/// AI tool related patterns
const AI_TOOL_PATTERNS: &[(&str, &str)] = &[
    // Aider
    (".aider", "Aider AI assistant cache"),
    (".aider.chat.history.md", "Aider chat history"),
    (".aider.input.history", "Aider input history"),
    (".aider.tags.cache.v3", "Aider tags cache"),
    // Claude
    (".claude", "Claude AI cache directory"),
    (".claude.json", "Claude configuration"),
    (".claude.json.backup", "Claude config backup"),
    ("claude_output", "Claude output directory"),
    // Cursor
    (".cursor", "Cursor AI cache"),
    (".cursorignore", "Cursor ignore file"),
    (".cursorrules", "Cursor rules file"),
    // Copilot
    (".copilot", "GitHub Copilot cache"),
    // Codeium
    (".codeium", "Codeium AI cache"),
    // Tabnine
    (".tabnine", "Tabnine AI cache"),
    // Codex
    (".codex", "OpenAI Codex cache"),
    // Continue
    (".continue", "Continue AI cache"),
    // Amazon Q / CodeWhisperer
    (".aws/amazonq", "Amazon Q cache"),
    (".aws/codewhisperer", "CodeWhisperer cache"),
    // Generic AI patterns
    (".ai_cache", "Generic AI cache"),
    (".llm_cache", "LLM cache directory"),
];

/// Temporary file patterns
const TEMP_FILE_PATTERNS: &[(&str, &str)] = &[
    (".tmp", "Temporary file"),
    (".temp", "Temporary file"),
    (".bak", "Backup file"),
    (".backup", "Backup file"),
    (".orig", "Original file backup"),
    (".old", "Old file"),
    ("~", "Editor temporary file"),
    (".swp", "Vim swap file"),
    (".swo", "Vim swap file"),
    (".DS_Store", "macOS metadata"),
    ("Thumbs.db", "Windows thumbnail cache"),
    ("desktop.ini", "Windows desktop config"),
];

/// Whitelist - files/directories to never delete
const WHITELIST_EXTENSIONS: &[&str] = &[
    // Audio
    "mp3", "wav", "flac", "aac", "ogg", "wma", "m4a", // Video
    "mp4", "avi", "mkv", "mov", "wmv", "flv", "webm", // Documents
    "pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx", "odt", "ods", "odp",
    // Images (important ones)
    "psd", "ai", "raw", "cr2", "nef", // Archives
    "zip", "rar", "7z", "tar", "gz",
];

const WHITELIST_DIRECTORIES: &[&str] = &[
    "node_modules",
    ".git",
    ".svn",
    "vendor",
    "venv",
    ".venv",
    "target",
    "__pycache__",
    "dist",
    "build",
];

/// Clamp depth when the user tries to scan the filesystem root
const ROOT_SCAN_MAX_DEPTH: usize = 8;

/// Format bytes to human readable string
fn format_size(bytes: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;

    if bytes >= GB {
        format!("{:.2} GB", bytes as f64 / GB as f64)
    } else if bytes >= MB {
        format!("{:.2} MB", bytes as f64 / MB as f64)
    } else if bytes >= KB {
        format!("{:.2} KB", bytes as f64 / KB as f64)
    } else {
        format!("{} B", bytes)
    }
}

/// Get directory size
fn get_size(path: &PathBuf) -> u64 {
    if path.is_file() {
        path.metadata().map(|m| m.len()).unwrap_or(0)
    } else {
        WalkDir::new(path)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter_map(|e| e.metadata().ok())
            .filter(|m| m.is_file())
            .map(|m| m.len())
            .sum()
    }
}

/// Check if a file/directory should be whitelisted
fn is_whitelisted(path: &Path) -> bool {
    let name = path
        .file_name()
        .map(|n| n.to_string_lossy().to_lowercase())
        .unwrap_or_default();

    // Check directory whitelist
    if path.is_dir() {
        for wl_dir in WHITELIST_DIRECTORIES {
            if name == *wl_dir {
                return true;
            }
        }
    }

    // Check extension whitelist
    if let Some(ext) = path.extension() {
        let ext_lower = ext.to_string_lossy().to_lowercase();
        if WHITELIST_EXTENSIONS.contains(&ext_lower.as_str()) {
            return true;
        }
    }

    false
}

/// Check if a file matches AI tool patterns
fn check_ai_tool_pattern(path: &Path) -> Option<(&'static str, &'static str)> {
    let name = path
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_default();

    for (pattern, reason) in AI_TOOL_PATTERNS {
        if name == *pattern || name.starts_with(pattern) {
            return Some((pattern, reason));
        }
    }

    // Check if in path
    let path_str = path.to_string_lossy().to_lowercase();
    for (pattern, reason) in AI_TOOL_PATTERNS {
        if path_str.contains(&format!("/{}/", pattern))
            || path_str.contains(&format!("\\{}\\", pattern))
        {
            return Some((pattern, reason));
        }
    }

    None
}

/// Check if a file matches temp file patterns
fn check_temp_pattern(path: &Path) -> Option<(&'static str, &'static str)> {
    let name = path
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_default();

    for (pattern, reason) in TEMP_FILE_PATTERNS {
        if name == *pattern || name.ends_with(pattern) {
            return Some((pattern, reason));
        }
    }

    None
}

/// Check for anomalous files (zero-byte, very short names, etc.)
fn check_anomalous(path: &Path) -> Option<String> {
    let name = path
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_default();

    // Zero-byte files (except known empty files)
    if path.is_file() {
        if let Ok(meta) = path.metadata() {
            if meta.len() == 0 && !name.starts_with(".git") && name != ".gitkeep" {
                return Some("Zero-byte file".to_string());
            }
        }
    }

    // Very short names that look suspicious
    if name.len() == 1
        && !name
            .chars()
            .next()
            .map(|c| c.is_alphanumeric())
            .unwrap_or(false)
    {
        return Some("Suspicious single-character name".to_string());
    }

    // Names with only special characters
    if !name.is_empty()
        && name
            .chars()
            .all(|c| !c.is_alphanumeric() && c != '.' && c != '_' && c != '-')
    {
        return Some("Name contains only special characters".to_string());
    }

    None
}

fn user_home_dir() -> Option<PathBuf> {
    #[cfg(target_os = "windows")]
    {
        if let Some(profile) = std::env::var_os("USERPROFILE") {
            return Some(PathBuf::from(profile));
        }
        if let (Some(drive), Some(path)) = (std::env::var_os("HOMEDRIVE"), std::env::var_os("HOMEPATH")) {
            let combined = format!("{}{}", drive.to_string_lossy(), path.to_string_lossy());
            return Some(PathBuf::from(combined));
        }
        None
    }

    #[cfg(not(target_os = "windows"))]
    {
        std::env::var_os("HOME").map(PathBuf::from)
    }
}

fn is_root_path(path: &Path) -> bool {
    path.parent().is_none()
}

fn scan_target(root: &Path, max_depth: usize) -> Vec<AiJunkFile> {
    let entries: Vec<_> = WalkDir::new(root)
        .max_depth(max_depth)
        .into_iter()
        .filter_entry(|e| !is_whitelisted(e.path()))
        .filter_map(|e| e.ok())
        .collect();

    entries
        .par_iter()
        .filter_map(|entry| {
            let path = entry.path().to_path_buf();

            // Check AI tool patterns
            if let Some((pattern, reason)) = check_ai_tool_pattern(&path) {
                let size = get_size(&path);
                return Some(AiJunkFile {
                    id: format!(
                        "ai_{}",
                        path.to_string_lossy().replace(['\\', '/', ' '], "_")
                    ),
                    name: entry.file_name().to_string_lossy().to_string(),
                    path: path.to_string_lossy().to_string(),
                    size,
                    size_display: format_size(size),
                    junk_type: "ai_tool".to_string(),
                    reason: format!("AI Tool: {} - {}", pattern, reason),
                });
            }

            // Check temp file patterns
            if let Some((pattern, reason)) = check_temp_pattern(&path) {
                let size = get_size(&path);
                return Some(AiJunkFile {
                    id: format!(
                        "temp_{}",
                        path.to_string_lossy().replace(['\\', '/', ' '], "_")
                    ),
                    name: entry.file_name().to_string_lossy().to_string(),
                    path: path.to_string_lossy().to_string(),
                    size,
                    size_display: format_size(size),
                    junk_type: "temp_file".to_string(),
                    reason: format!("Temp: {} - {}", pattern, reason),
                });
            }

            // Check anomalous files
            if let Some(reason) = check_anomalous(&path) {
                let size = get_size(&path);
                return Some(AiJunkFile {
                    id: format!(
                        "anomaly_{}",
                        path.to_string_lossy().replace(['\\', '/', ' '], "_")
                    ),
                    name: entry.file_name().to_string_lossy().to_string(),
                    path: path.to_string_lossy().to_string(),
                    size,
                    size_display: format_size(size),
                    junk_type: "anomalous".to_string(),
                    reason,
                });
            }

            None
        })
        .collect()
}

/// Scan a directory for AI junk files
pub fn scan_ai_junk(root_path: &str, max_depth: usize) -> Vec<AiJunkFile> {
    let root = PathBuf::from(root_path);
    if !root.exists() {
        return Vec::new();
    }

    let mut effective_depth = max_depth;
    let mut targets = vec![root.clone()];

    if is_root_path(&root) {
        effective_depth = effective_depth.min(ROOT_SCAN_MAX_DEPTH);
        if let Some(home) = user_home_dir() {
            if home.exists() {
                targets = vec![home];
            }
        }
    }

    let mut junk_files: Vec<AiJunkFile> = targets
        .par_iter()
        .flat_map(|target| scan_target(target, effective_depth))
        .collect();

    // De-duplicate by full path to avoid repeats when targets overlap
    let mut by_path: HashMap<String, AiJunkFile> = HashMap::new();
    for file in junk_files.drain(..) {
        by_path.insert(file.path.clone(), file);
    }
    let mut junk_files: Vec<AiJunkFile> = by_path.into_values().collect();

    // Sort by size descending
    junk_files.sort_by(|a, b| b.size.cmp(&a.size));

    // Assign sequential IDs
    for (id_counter, file) in junk_files.iter_mut().enumerate() {
        file.id = format!("junk_{}", id_counter);
    }

    junk_files
}

/// Delete an AI junk file with permission retry
pub fn delete_ai_junk(path: &str) -> Result<String, String> {
    let file_path = PathBuf::from(path);

    if !file_path.exists() {
        return Err(format!("File does not exist: {}", path));
    }

    // Check for Windows reserved names
    #[cfg(target_os = "windows")]
    {
        let name = file_path
            .file_name()
            .map(|n| n.to_string_lossy().to_lowercase())
            .unwrap_or_default();
        let reserved = ["con", "prn", "aux", "nul", "com1", "com2", "com3", "com4", 
                        "com5", "com6", "com7", "com8", "com9", "lpt1", "lpt2", "lpt3", 
                        "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9"];
        let name_without_ext = name.split('.').next().unwrap_or(&name);
        if reserved.contains(&name_without_ext) {
            return Err(format!("Cannot delete Windows reserved name: {}", path));
        }
    }

    // Get size before deletion
    let size = get_size(&file_path);

    // Try to delete
    let result = if file_path.is_dir() {
        fs::remove_dir_all(&file_path)
    } else {
        fs::remove_file(&file_path)
    };

    match result {
        Ok(_) => Ok(format!(
            "Successfully deleted {} (freed {})",
            path,
            format_size(size)
        )),
        Err(e) => {
            // Try with permission fix
            #[cfg(target_os = "windows")]
            {
                if fix_permissions_and_delete(&file_path).is_ok() {
                    return Ok(format!(
                        "Successfully deleted {} (freed {})",
                        path,
                        format_size(size)
                    ));
                }
            }

            #[cfg(unix)]
            {
                if chmod_and_delete(&file_path).is_ok() {
                    return Ok(format!(
                        "Successfully deleted {} (freed {})",
                        path,
                        format_size(size)
                    ));
                }
            }

            Err(format!("Failed to delete {}: {}", path, e))
        }
    }
}

#[cfg(target_os = "windows")]
#[allow(clippy::permissions_set_readonly_false)]
fn fix_permissions_and_delete(path: &PathBuf) -> std::io::Result<()> {
    use std::os::windows::fs::MetadataExt;

    // Remove readonly attribute
    if let Ok(metadata) = fs::metadata(path) {
        if metadata.file_attributes() & 1 != 0 {
            let mut perms = metadata.permissions();
            perms.set_readonly(false);
            fs::set_permissions(path, perms)?;
        }
    }

    if path.is_dir() {
        // Recursively fix permissions
        for entry in WalkDir::new(path).into_iter().filter_map(|e| e.ok()) {
            if let Ok(metadata) = fs::metadata(entry.path()) {
                if metadata.file_attributes() & 1 != 0 {
                    let mut perms = metadata.permissions();
                    perms.set_readonly(false);
                    let _ = fs::set_permissions(entry.path(), perms);
                }
            }
        }
        fs::remove_dir_all(path)
    } else {
        fs::remove_file(path)
    }
}

#[cfg(unix)]
fn chmod_and_delete(path: &PathBuf) -> std::io::Result<()> {
    use std::os::unix::fs::PermissionsExt;

    // Set write permission
    if let Ok(metadata) = fs::metadata(path) {
        let mut perms = metadata.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(path, perms)?;
    }

    if path.is_dir() {
        fs::remove_dir_all(path)
    } else {
        fs::remove_file(path)
    }
}
